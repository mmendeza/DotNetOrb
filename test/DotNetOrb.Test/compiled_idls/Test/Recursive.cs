/**
 * Generated by DotNetORb.IdlCompiler V 1.0.0.0
 * Timestamp: 26/02/2024 12:18:44
 *
 */

using System;
using System.Collections.Generic;
using System.Linq;
using CORBA;


namespace Test
{
	public abstract partial class Recursive : CORBA.Object, Test.IRecursive
	{
		[RepositoryID("IDL:Test/Recursive/Foo:1.0")]
		[Helper(typeof(FooHelper))]
		public partial class Foo: CORBA.IIDLEntity, IEquatable<Test.Recursive.Foo>
		{
			[IdlName("Foo")]
			public int Value { get; set; }
			[IdlName("Foo")]
			public Test.Recursive.Foo[] Chain { get; set; }

			public Foo()
			{
			}

			public Foo(Foo other)
			{
				Value = other.Value;
				Chain = other.Chain;
			}

			public Foo(int value, Test.Recursive.Foo[] chain)
			{
				this.Value = value;
				this.Chain = chain;
			}

			public bool Equals(Test.Recursive.Foo? other)
			{
				if (other == null) return false;
				if (!Value.Equals(other.Value)) return false;
				if (!Chain.SequenceEqual(other.Chain)) return false;
				return true;
			}
		}

		public static class FooHelper
		{
			private static volatile CORBA.TypeCode type;

			public static CORBA.TypeCode Type()
			{
				if (type == null)
				{
					lock (typeof(FooHelper))
					{
						if (type == null)
						{
							type = CORBA.ORB.Init().CreateStructTc(Test.Recursive.FooHelper.Id(), "Foo", new CORBA.StructMember[] {new CORBA.StructMember("value", CORBA.ORB.Init().GetPrimitiveTc((CORBA.TCKind) 3), null), new CORBA.StructMember("chain", CORBA.ORB.Init().CreateSequenceTc(0, CORBA.ORB.Init().CreateRecursiveTc("IDL:Test/Recursive/Foo:1.0")), null), });
						}
					}
				}
				return type;
			}

			public static void Insert(CORBA.Any any, Test.Recursive.Foo s)
			{
				any.Type = Type();
				Write(any.CreateOutputStream(), s);
			}

			public static Test.Recursive.Foo Extract(CORBA.Any any)
			{
				var inputStream = any.CreateInputStream();
				try
				{
					return Read(inputStream);
				}
				finally
				{
					inputStream.Close();
				}
			}

			public static string Id()
			{
				return "IDL:Test/Recursive/Foo:1.0";
			}

			public static Test.Recursive.Foo Read(CORBA.IInputStream inputStream)
			{
				var result = new Test.Recursive.Foo();
				result.Value = inputStream.ReadLong();
				{
					var _capacity0 = inputStream.ReadLong();
					if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
					{
						throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
					}
					result.Chain = new Test.Recursive.Foo[_capacity0];
					for (int i0 = 0; i0 < _capacity0; i0++)
					{
						Test.Recursive.Foo _item0;
						_item0 = Test.Recursive.FooHelper.Read(inputStream);
						result.Chain[i0] = _item0;
					}
				}
				return result;
			}

			public static void Write(CORBA.IOutputStream outputStream, Test.Recursive.Foo s)
			{
				outputStream.WriteLong(s.Value);
				{
					outputStream.WriteLong(s.Chain.Length);
					for (int i0 = 0; i0 < s.Chain.Length; i0++)
					{
						Test.Recursive.FooHelper.Write(outputStream, s.Chain[i0]);
					}
				}
			}

		}
		public static class FooSeqHelper
		{
			private static volatile CORBA.TypeCode type;

			public static CORBA.TypeCode Type()
			{
				if (type == null)
				{
					lock (typeof(FooSeqHelper))
					{
						if (type == null)
						{
							type = CORBA.ORB.Init().CreateAliasTc(Test.Recursive.FooSeqHelper.Id(), "FooSeq", CORBA.ORB.Init().CreateSequenceTc(0, Test.Recursive.FooHelper.Type()));
						}
					}
				}
				return type;
			}

			public static void Insert(CORBA.Any any, Test.Recursive.Foo[] value)
			{
				any.Type = Type();
				Write(any.CreateOutputStream(), value);
			}

			public static Test.Recursive.Foo[] Extract(CORBA.Any any)
			{
				var inputStream = any.CreateInputStream();
				try
				{
					return Read(inputStream);
				}
				finally
				{
					inputStream.Close();
				}
			}

			public static string Id()
			{
				return "IDL:Test/Recursive/FooSeq:1.0";
			}

			public static Test.Recursive.Foo[] Read(CORBA.IInputStream inputStream)
			{
				Test.Recursive.Foo[] result;
				{
					var _capacity0 = inputStream.ReadLong();
					if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
					{
						throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
					}
					result = new Test.Recursive.Foo[_capacity0];
					for (int i0 = 0; i0 < _capacity0; i0++)
					{
						Test.Recursive.Foo _item0;
						_item0 = Test.Recursive.FooHelper.Read(inputStream);
						result[i0] = _item0;
					}
				}
				return result;
			}

			public static void Write(CORBA.IOutputStream outputStream, Test.Recursive.Foo[] value)
			{
				{
					outputStream.WriteLong(value.Length);
					for (int i0 = 0; i0 < value.Length; i0++)
					{
						Test.Recursive.FooHelper.Write(outputStream, value[i0]);
					}
				}
			}

		}
		[IdlName("Bar")]
		[RepositoryID("IDL:Test/Recursive/Bar:1.0")]
		[Helper(typeof(BarHelper))]
		public partial class Bar: CORBA.IIDLEntity, IEquatable<Bar>
		{
		[RepositoryID("IDL:Test/Recursive/Bar/Foo:1.0")]
		[Helper(typeof(FooHelper))]
		public partial class Foo: CORBA.IIDLEntity, IEquatable<Test.Recursive.Bar.Foo>
		{
			[IdlName("Foo")]
			public double DMem { get; set; }
			[IdlName("Foo")]
			public Test.Recursive.Bar[] Nested { get; set; }

			public Foo()
			{
			}

			public Foo(Foo other)
			{
				DMem = other.DMem;
				Nested = other.Nested;
			}

			public Foo(double dMem, Test.Recursive.Bar[] nested)
			{
				this.DMem = dMem;
				this.Nested = nested;
			}

			public bool Equals(Test.Recursive.Bar.Foo? other)
			{
				if (other == null) return false;
				if (!DMem.Equals(other.DMem)) return false;
				if (!Nested.SequenceEqual(other.Nested)) return false;
				return true;
			}
		}

		public static class FooHelper
		{
			private static volatile CORBA.TypeCode type;

			public static CORBA.TypeCode Type()
			{
				if (type == null)
				{
					lock (typeof(FooHelper))
					{
						if (type == null)
						{
							type = CORBA.ORB.Init().CreateStructTc(Test.Recursive.Bar.FooHelper.Id(), "Foo", new CORBA.StructMember[] {new CORBA.StructMember("d_mem", CORBA.ORB.Init().GetPrimitiveTc((CORBA.TCKind) 7), null), new CORBA.StructMember("nested", CORBA.ORB.Init().CreateSequenceTc(0, CORBA.ORB.Init().CreateRecursiveTc("IDL:Test/Recursive/Bar:1.0")), null), });
						}
					}
				}
				return type;
			}

			public static void Insert(CORBA.Any any, Test.Recursive.Bar.Foo s)
			{
				any.Type = Type();
				Write(any.CreateOutputStream(), s);
			}

			public static Test.Recursive.Bar.Foo Extract(CORBA.Any any)
			{
				var inputStream = any.CreateInputStream();
				try
				{
					return Read(inputStream);
				}
				finally
				{
					inputStream.Close();
				}
			}

			public static string Id()
			{
				return "IDL:Test/Recursive/Bar/Foo:1.0";
			}

			public static Test.Recursive.Bar.Foo Read(CORBA.IInputStream inputStream)
			{
				var result = new Test.Recursive.Bar.Foo();
				result.DMem = inputStream.ReadDouble();
				{
					var _capacity0 = inputStream.ReadLong();
					if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
					{
						throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
					}
					result.Nested = new Test.Recursive.Bar[_capacity0];
					for (int i0 = 0; i0 < _capacity0; i0++)
					{
						Test.Recursive.Bar _item0;
						_item0 = Test.Recursive.BarHelper.Read(inputStream);
						result.Nested[i0] = _item0;
					}
				}
				return result;
			}

			public static void Write(CORBA.IOutputStream outputStream, Test.Recursive.Bar.Foo s)
			{
				outputStream.WriteDouble(s.DMem);
				{
					outputStream.WriteLong(s.Nested.Length);
					for (int i0 = 0; i0 < s.Nested.Length; i0++)
					{
						Test.Recursive.BarHelper.Write(outputStream, s.Nested[i0]);
					}
				}
			}

		}
			public Bar()
			{
			}

			public Bar(Bar other)
			{
				_Discriminator = other._Discriminator;
				LMem = other.LMem;
				SMem = other.SMem;
			}

			public bool Equals(Bar? other)
			{
				if (other == null) return false;
				if (_Discriminator != other._Discriminator) return false;
				switch (_Discriminator)
				{
					case 0:
						if (!LMem.Equals(other.LMem)) return false;
						break;
					case 1:
						if (!SMem.Equals(other.SMem)) return false;
						break;
				}
				return true;
			}

			public int _Discriminator { get; private set; }

			private int _lMem;
			public int LMem
			{
				get
				{
					if (_Discriminator != 0) throw new System.InvalidOperationException();
					return _lMem;
				}
				set
				{
					_Discriminator = 0;
					_lMem = value;
				}
			}
			private Test.Recursive.Bar.Foo _sMem;
			public Test.Recursive.Bar.Foo SMem
			{
				get
				{
					if (_Discriminator != 1) throw new System.InvalidOperationException();
					return _sMem;
				}
				set
				{
					_Discriminator = 1;
					_sMem = value;
				}
			}
		}

		public static class BarHelper
		{
			private static volatile CORBA.TypeCode type;

			public static CORBA.TypeCode Type()
			{
				if (type == null)
				{
					lock (typeof(BarHelper))
					{
						if (type == null)
						{
							var members = new List<CORBA.UnionMember>();
							CORBA.Any anyLabel;
							anyLabel = CORBA.ORB.Init().CreateAny();
							anyLabel.InsertLong(0);
							members.Add(new CORBA.UnionMember("l_mem", anyLabel, CORBA.ORB.Init().GetPrimitiveTc((CORBA.TCKind) 3), null));
							type = CORBA.ORB.Init().CreateUnionTc(Test.Recursive.BarHelper.Id(), "Bar", CORBA.ORB.Init().GetPrimitiveTc((CORBA.TCKind) 3), members.ToArray());
							anyLabel = CORBA.ORB.Init().CreateAny();
							anyLabel.InsertLong(1);
							members.Add(new CORBA.UnionMember("s_mem", anyLabel, Test.Recursive.Bar.FooHelper.Type(), null));
							type = CORBA.ORB.Init().CreateUnionTc(Test.Recursive.BarHelper.Id(), "Bar", CORBA.ORB.Init().GetPrimitiveTc((CORBA.TCKind) 3), members.ToArray());
						}
					}
				}
				return type;
			}

			public static void Insert(CORBA.Any any, Test.Recursive.Bar value)
			{
				any.Type = Type();
				Write(any.CreateOutputStream(), value);
			}

			public static Test.Recursive.Bar Extract(CORBA.Any any)
			{
				var inputStream = any.CreateInputStream();
				try
				{
					return Read(inputStream);
				}
				finally
				{
					inputStream.Close();
				}
			}

			public static string Id()
			{
			    return "IDL:Test/Recursive/Bar:1.0";
			}

			public static Test.Recursive.Bar Read(CORBA.IInputStream inputStream)
			{
				var result = new Test.Recursive.Bar();
				int disc;
				disc = inputStream.ReadLong();
				switch (disc)
				{
					case 0:
					{
						result.LMem = inputStream.ReadLong();
						break;
					}
					case 1:
					{
						result.SMem = Test.Recursive.Bar.FooHelper.Read(inputStream);
						break;
					}
				}
				return result;
			}

			public static void Write(CORBA.IOutputStream outputStream, Test.Recursive.Bar value)
			{
				outputStream.WriteLong(value._Discriminator);
				switch (value._Discriminator)
				{
					case 0:
					{
						outputStream.WriteLong(value.LMem);
						break;
					}
					case 1:
					{
						Test.Recursive.Bar.FooHelper.Write(outputStream, value.SMem);
						break;
					}
				}
			}

		}
		public static class BarSeqHelper
		{
			private static volatile CORBA.TypeCode type;

			public static CORBA.TypeCode Type()
			{
				if (type == null)
				{
					lock (typeof(BarSeqHelper))
					{
						if (type == null)
						{
							type = CORBA.ORB.Init().CreateAliasTc(Test.Recursive.BarSeqHelper.Id(), "BarSeq", CORBA.ORB.Init().CreateSequenceTc(0, Test.Recursive.BarHelper.Type()));
						}
					}
				}
				return type;
			}

			public static void Insert(CORBA.Any any, Test.Recursive.Bar[] value)
			{
				any.Type = Type();
				Write(any.CreateOutputStream(), value);
			}

			public static Test.Recursive.Bar[] Extract(CORBA.Any any)
			{
				var inputStream = any.CreateInputStream();
				try
				{
					return Read(inputStream);
				}
				finally
				{
					inputStream.Close();
				}
			}

			public static string Id()
			{
				return "IDL:Test/Recursive/BarSeq:1.0";
			}

			public static Test.Recursive.Bar[] Read(CORBA.IInputStream inputStream)
			{
				Test.Recursive.Bar[] result;
				{
					var _capacity0 = inputStream.ReadLong();
					if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
					{
						throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
					}
					result = new Test.Recursive.Bar[_capacity0];
					for (int i0 = 0; i0 < _capacity0; i0++)
					{
						Test.Recursive.Bar _item0;
						_item0 = Test.Recursive.BarHelper.Read(inputStream);
						result[i0] = _item0;
					}
				}
				return result;
			}

			public static void Write(CORBA.IOutputStream outputStream, Test.Recursive.Bar[] value)
			{
				{
					outputStream.WriteLong(value.Length);
					for (int i0 = 0; i0 < value.Length; i0++)
					{
						Test.Recursive.BarHelper.Write(outputStream, value[i0]);
					}
				}
			}

		}
		[IdlName("SendFoo")]
		public abstract Test.Recursive.Foo SendFoo(Test.Recursive.Foo f);
		[IdlName("SendBar")]
		public abstract Test.Recursive.Bar SendBar(Test.Recursive.Bar b);
		[IdlName("SendAny")]
		public abstract CORBA.Any SendAny(CORBA.Any a);
		[IdlName("SendAny")]
		public abstract Task<CORBA.Any> SendAnyAsync(CORBA.Any a);
	}
}

